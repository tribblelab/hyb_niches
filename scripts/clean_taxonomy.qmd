---
title: "clean_taxonomy"
output: html_document
date: "2026-02-04"
---

# clean taxonomy: pull taxa names & build dict of synonyms

## load packages

```{julia}
using CSV, DataFrames
using JLD2
```

## load in taxa list df

We're only focusing on clade 1 (south) + 2b (central-northish), so let's filter down to that clade.

```{julia}
taxa_traits = DataFrame(CSV.File("data/SupTable4-TraitsSpecies.csv"))
#clean up column names - change from all caps to lowercase
rename!(lowercase, taxa_traits)
#remove spaces
rename!(x -> replace(x, ' ' => '_'), taxa_traits)
filter!(:clade => x -> x == "1" || x == "2b", taxa_traits)
```

```{julia}
rename!(taxa_traits, Dict(:species => "scientificName"))
scientificName = replace.(taxa_traits.scientificName, "C. " => "Calceolaria ")
taxa_traits.scientificName = scientificName
#make a specificEpithet col
specificEpithet      = [split(taxa, " ")[2] for taxa in scientificName]
#make an infraspecificEpithet col (splitting on var. or subsp.)
infraspecificEpithet = Vector{Union{String,Missing}}()
for taxa in scientificName
    parts = split(taxa, " ")
    if length(parts) >= 4
        push!(infraspecificEpithet, parts[4])
    else
        push!(infraspecificEpithet, missing)
    end
end

insertcols!(taxa_traits, 2, :specificEpithet => specificEpithet)
insertcols!(taxa_traits, 3, :infraspecificEpithet => infraspecificEpithet)
```

## load in powo checklist

I ran a Kew / Plants of the World Online checklist for Calceolaria species at the botanical country level
on 2026-02-04, using native/introduced taxa.

```{julia}
lines = readlines("data/powochecklist.txt")
#pull lines starting from valid species (skipping headers)
subset = lines[9:1110]
#join back into a single string
text = join(subset, "\n")
#split on one or more empty lines
blocks = split(text, r"\n\s*\n+")
```

### compare names from anahí with powo valid names

```{julia}
#define regex pattern just to pull full name before species authority
pat = Regex(
    "^(.+?)\\s+(?=\\(|[A-Z])",
    "m"
)

validnames = String[]
#grab valid names and add to this vector
for block in blocks
    push!(validnames, strip(match(pat, block)[1]))
end

discrepancies = String[]
for name in scientificName
    if name ∉ validnames
        push!(discrepancies, name)
    end
end

discrepancies
```

### reconcile discrepancies with powo

1.  "Calceolaria ascendens subsp. exigua” —> Kew says this is a synonym for "Calceolaria ascendens subsp. glandulifera"
>> This one is C. ascendens glandulifera
we already have C. ascendens glandulifera in the df, so let's delete this line.

```{julia}
#delete this entry from df
deleteat!(taxa_traits, findall(==("Calceolaria ascendens subsp. exigua"), taxa_traits.scientificName))
```

2.  "Calceolaria petiolaris” —> Kew says this is a synonym for “C. petioalaris"
>> You're right. This is a typo. It is C. petioalaris

```{julia}
#replace petiolaris with "petioalaris"
replace!(taxa_traits.scientificName, "Calceolaria petiolaris" => "Calceolaria petioalaris")
replace!(taxa_traits.specificEpithet, "petiolaris" => "petioalaris")
```

3.  "Calceolaria corymbosa subsp. montana” —> Kew says this is a synonym for "Calceolaria mollissima"
>> The right species to use here is C. corymbosa montana (mollissima is an old name)

instead of changing the dataframe or dictionary, I'll just add an if statement to the synonym matching with the POWO checklist below.

4.  "Calceolaria crenatifolia”  —> Kew doesn’t have anything for “crenatifolia”, but they do have “crenatiflora” accepted
>> Another typo. This is C. crenatiflora indeed.

```{julia}
#replace crenatifolia with "crenatiflora"
replace!(taxa_traits.scientificName, "Calceolaria crenatifolia" => "Calceolaria crenatiflora")
replace!(taxa_traits.specificEpithet, "crenatifolia" => "crenatiflora")
```

5.  "Calceolaria corymbosa subsp. santiagana” —> I think you have a typo, should be "santiagina"
>> Another typo. This is C. corymbosa santiagina (with an "i")

```{julia}
#replace santiagana with "santiagina"
replace!(taxa_traits.scientificName, "Calceolaria corymbosa subsp. santiagana" => "Calceolaria corymbosa subsp. santiagina")
replace!(taxa_traits.infraspecificEpithet, "santiagana" => "santiagina")
```

let's initialize dictionary of valid names to synonyms for just the taxa we want:

```{julia}
synonymdict = Dict{String, Vector}()
for taxa in scientificName
    synonymdict[taxa] = [taxa]
end
```

6.  "Calceolaria dentata subsp. cummingiana” —> Kew has one m in “cumingiana” but on the internet I see 2 ms (“cummingiana”) in other sources
>> This one is C. dentata cummingiana (with two "m"s)

```{julia}
#let's manually add "dentata subsp. cumingiana" to synonyms to cover our bases
push!(synonymdict["Calceolaria dentata subsp. cummingiana"], ("Calceolaria dentata subsp. cumingiana"))
```

## create synonym dictionary

```{julia}
powosynonyms = lines[1112:end]

for name in scientificName
    keyname = name
    if name == "Calceolaria corymbosa subsp. montana"
        push!(synonymdict[name], ("Calceolaria mollissima"))
        name = "Calceolaria mollissima"
    end
    validnamepat = Regex("=== \\Q$name\\E\\s+(?=\\(|[A-Z])")
    synonympat = Regex("^(.+?)\\s+(?=\\(|[A-Z])")
    potentialmatches = findall( x -> occursin(validnamepat, x), powosynonyms)
    if !isempty(potentialmatches)
        for i in potentialmatches
            line = powosynonyms[i]
            synonym = strip(match(synonympat, line)[1])
            push!(synonymdict[keyname], (synonym))       
        end
    end
end
```

check this worked:
look at dictionary values with synonyms (list length > 1)
```{julia}
for k in keys(synonymdict)
    if length(synonymdict[k]) > 1
        @show k synonymdict[k]
    end
end
```

```{julia}
save("data/synonymdict.jld2", synonymdict)
```

## consider edge cases

examples:
1. Calceolaria heterophylla --> two definitions, one valid one not. The one not is a synonym for a different taxon. do I need species authorities stored somewhere?

```{julia}
# create a set of names that appear as synonyms
synonym_names = Set{String}()
synonympat = Regex("^(.+?)\\s+(?=\\(|[A-Z])")

for line in powosynonyms
    if occursin("===", line)
        m = match(synonympat, line)
        if m !== nothing
            synonym = strip(m[1])
            push!(synonym_names, synonym)
        end
    end
end

# find taxa that appear in both valid names and synonym names
valid_set = Set(validnames)
duplicated_taxa = intersect(valid_set, synonym_names)
# of those, find the taxa in our dataset
intersect(taxa_traits.scientificName, duplicated_taxa)
```

let's modify the dataframe to add in who is our correct species authority.

```{julia}
# create a dictionary mapping species names to their authorities
authority_dict = Dict{String, String}()

for block in blocks
    # get the first line of the block (the main species entry)
    first_line = split(block, "\n")[1]
    
    # extract the name
    name_match = match(pat, first_line)
    if name_match !== nothing
        name = strip(name_match[1])
        
        # extract the specific epithet (and infraspecific if present)
        name_parts = split(name, " ")
        epithet = name_parts[2]  # get the specific epithet
        if length(name_parts) > 2
            # for subspecies/varieties, include those parts too
            epithet = join(name_parts[2:end], " ")
        end
        
        # extract authority: everything after the name until the comma or period
        # this regex captures text between the epithet and the first comma or period
        authority_pattern = Regex("\\b$(epithet)\\s+(.+?),")
        authority_match = match(authority_pattern, first_line)
        
        if authority_match !== nothing
            authority = strip(authority_match[1])
            # remove anything after " in " (including " in " itself)
            authority = replace(authority, r"\s+in\s+.*$" => "")
            authority_dict[name] = authority
        end
    end
endå

# Add the speciesAuthority column to taxa_traits
taxa_traits.speciesAuthority = [get(authority_dict, name, missing) for name in taxa_traits.scientificName]
```

write out clean version of df:
```{julia}
CSV.write("data/traits_species_cleaned-2026_02_09.csv", taxa_traits)
```

2. check to see if I have anything like one sample C. filicaulis and another C. filicaulis luxurians --> in which case, do you filter out all the luxurians for the former? what makes sense for niche modeling? how many occurrences do i have for taxa that are at the infraspecific level?

```{julia}
#filter data frame for matches at specificEpithet
gdf = groupby(taxa_traits, :specificEpithet)
duplicated_specifictaxa = filter(g -> nrow(g) > 1, gdf) |> DataFrame
ismissing(duplicated_specifictaxa) #false
```

No, we don't have any instances of this. good!